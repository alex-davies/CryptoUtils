using System;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace Ink.Utils.Encryption
{
    public interface IHasher
    {
        /// <summary>
        /// Hashes data using the given salt and iterations, returning a hash of hashByteSize.
        /// </summary>
        /// <param name="data">dat to hash.</param>
        /// <param name="salt">salt to use when hashing.</param>
        /// <param name="iterations">number of iterations to use when hashing.</param>
        /// <param name="hashByteSize">size of resulting hash.</param>
        /// <returns>hashed value</returns>
        byte[] Hash(byte[] data, byte[] salt, int iterations, int hashByteSize);
    }

    public static class HasherExtensions
    {
        /// <summary>
        /// Hashes the given data
        /// </summary>
        /// <param name="hasher"></param>
        /// <param name="data">the data to hash.</param>
        /// <param name="saltByteSize">size of the generated salt in bytes.</param>
        /// <param name="iterations">number of iterations to perform the hashing with</param>
        /// <param name="hashByteSize">size of the generated hash in bytes.</param>
        /// <returns>hash string with iteraitons and salt encoded</returns>
        public static string Hash(this IHasher hasher, string data, int saltByteSize = 24, int iterations = 10000, int hashByteSize = 24)
        {
            //generate a random salt
            var salt = new byte[saltByteSize];
            using (var rng = new RNGCryptoServiceProvider())
            {
                rng.GetBytes(salt);
            }

            var hash = hasher.Hash(Encoding.UTF8.GetBytes(data), salt, iterations, hashByteSize);

            //we will encode the iterations and salt into the hash. This makes it easier to check a hash later.
            return string.Join(":", iterations, Convert.ToBase64String(salt), Convert.ToBase64String(hash));
        }

        /// <summary>
        /// Checks a hash matches the given data
        /// </summary>
        /// <param name="hasher">hasher</param>
        /// <param name="data">data that is to be checked.</param>
        /// <param name="hash">hash that is to be checked.</param>
        /// <returns>true if the hash matches, otherwise false</returns>
        public static bool CheckHash(this IHasher hasher, string data, string hash)
        {
            //we make the assumption the hash was generated by the 'hash' method
            //that would mean our iterations and salt are already embedded in the
            //hash value
            var hashSplit = hash.Split(':');
            if (hashSplit.Length != 3)
                return false;

            int iterations;
            byte[] salt;
            byte[] dataFromHash;

            try
            {
                if (!int.TryParse(hashSplit[0], out iterations))
                    return false;
                salt = Convert.FromBase64String(hashSplit[1]);
                dataFromHash = Convert.FromBase64String(hashSplit[2]);
            }
            catch (FormatException)
            {
                //occurs if we cant decode the base64
                return false;
            }

            var hashedData = hasher.Hash(Encoding.UTF8.GetBytes(data), salt, iterations, dataFromHash.Length);
            return hashedData.SequenceEqual(dataFromHash);
        }
    }

    public class Hasher : IHasher
    {
        public byte[] Hash(byte[] data, byte[] salt, int iterations, int hashByteSize)
        {
            using (var rfc2898DeriveBytes = new Rfc2898DeriveBytes(data, salt, iterations))
            {
                return rfc2898DeriveBytes.GetBytes(hashByteSize);
            }
        }
    }
}